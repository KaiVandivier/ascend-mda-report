<style type="text/css" media="screen">
  /* Put your CSS styling here */

  /* Rows that are not category labels */
  th[scope="row"]:not([colspan]) {
    font-weight: normal;
  }
</style>

<script type="text/javascript">
  // Put your javascript functions here

  jQuery(document).ready(function () {
    // Put javascript to be executed after page is loaded here

    /* Start boilerplate */
    // This is not working b/c orgunit/period error in forms
    // const orgUnit = dhis2.report.organisationUnit; // An object
    // const id = orgUnit.id;
    // const name = orgUnit.name;
    // const code = orgUnit.code;

    // const orgUnitHierarchy = dhis2.report.organisationUnitHierarchy; // An array with org unit objects for the hierarchy (current org unit first)
    // const name = orgUnitHierarchy[0].name;

    // const orgUnitChildren = dhis2.report.organisationUnitChildren; // An array with child org unit objects

    // const date = dhis2.report.date; // A date in yyyy-MM-dd format

    // const periods = dhis2.report.periods; // An array with period identifiers
    // const period = periods[0];
    /** End boilerplate */

    // Defining these values here because form creation error isn't saving report parameter settings
    const period = "THIS_MONTH";
    const orgUnit = "GdH306UQ8L8"; // This is the global org-unit

    // Parallel promises to fetch indicators and programIndicators
    Promise.all([
      $.get(
        "../api/programIndicators.json?filter=displayName:like:MDA&paging=false"
      ),
      $.get("../api/indicators.json?filter=displayName:like:MDA&paging=false"),
    ]).then((values) => {
      const [{ programIndicators }, { indicators }] = values;
      const allDimensions = [...programIndicators, ...indicators];

      // Remove "loading"
      $("#loading").remove();

      /* Setting up table */
      // Some enums I might use
      const columnSubcategories = Object.freeze({
        ROUND_1: "Round 1",
        ROUND_2: "Round 2",
        TOTAL: "Total",
      });
      const rowTypes = Object.freeze({
        CATEGORY: "category",
        PROGRAM_INDICATOR: "programIndicator",
        INDICATOR: "indicator",
      });
      // Enum for program indicator names? -- Maybe not, just put it in `rows`

      // Column and row values
      // TODO: Add short names
      const columns = [
        {
          name: "Trachoma MDA",
          shortName: "Trach.",
          prefix: "TCMDA",
          subcategories: null,
        },
        {
          name: "Lymphatic Filariasis MDA",
          shortName: "L.F.",
          prefix: "LFMDA",
          subcategories: null,
        },
        {
          name: "Onchocerciasis MDA",
          shortName: "Oncho.",
          prefix: "OMDA",
          subcategories: [
            columnSubcategories.ROUND_1,
            columnSubcategories.ROUND_2,
            columnSubcategories.TOTAL,
          ],
        },
        {
          name: "Schistosomiasis MDA",
          shortName: "Schisto.",
          prefix: "SCMDA",
          subcategories: [
            columnSubcategories.ROUND_1,
            columnSubcategories.ROUND_2,
            columnSubcategories.TOTAL,
          ],
        },
        {
          name: "Soil-transmitted Helminthiasis MDA",
          shortName: "STH",
          prefix: "STMDA",
          subcategories: [
            columnSubcategories.ROUND_1,
            columnSubcategories.ROUND_2,
            columnSubcategories.TOTAL,
          ],
        },
        {
          name: "Grand Total",
          shortName: "Grand Total",
          prefix: null,
          subcategories: null,
        },
      ];

      const rows = [
        // Endemicity
        { name: "Endemicity", type: rowTypes.CATEGORY },
        { name: "Endemic IUs", type: rowTypes.PROGRAM_INDICATOR },
        {
          name: "IUs which reached the criteria to stop MDA",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs in post-treatment surveillance",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs eligible for post MDA surveillance phase",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs where NTD endemicity is unknown",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "Population in NTD affected IUs",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          // Note: there seems to be a typo on this name in the DB (extra space at the end)
          name: "IUs eligible for pre-TAS surveys",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs eligible for TAS/IA surveys",
          type: rowTypes.PROGRAM_INDICATOR,
        },

        // Targets
        { name: "Targets", type: rowTypes.CATEGORY },
        { name: "Total Population of IUs", type: rowTypes.PROGRAM_INDICATOR },
        {
          name: "Population eligible for MDA treatment",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "Estimated size of populations with high risk of infection",
          type: rowTypes.PROGRAM_INDICATOR,
        },

        // Coverage
        { name: "Coverage", type: rowTypes.CATEGORY },
        // {
        //   // Causes "division by zero" error in database, specifically from TCMDA (uses "Epidemiological")
        //   name: "National Coverage",
        //   type: rowTypes.PROGRAM_INDICATOR,
        // },
        { name: "Program Coverage", type: rowTypes.PROGRAM_INDICATOR },
        // {
        //   // Same "division" error as above b/c TCMDA and LFMDA
        //   name: "Epidemiological Coverage",
        //   type: rowTypes.PROGRAM_INDICATOR,
        // },
        {
          name: "IUs reaching targeted program coverage",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name:
            "IUs reaching target therapeutic coverage within populations with high risk of infection",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs where MDA treatment has been provided",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "MDA treatments distributed to high risk populations",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        // Display name: "Number of PC treatments provided per IU (per disease)"
        { name: "Total Persons Treated", type: rowTypes.PROGRAM_INDICATOR },
        {
          name: "IUs where MDA campaigns were conducted",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs reaching required therapeutic coverage",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        // Similar to above, so displayName: "Number of people, in population eligible for treatment, receiving MDA treatment"
        { name: "Total Persons Treated", type: rowTypes.PROGRAM_INDICATOR },
        // This one seems off
        {
          name:
            "People, in population eligible for treatment, not receiving MDA treatment",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IU supported with NTD MDA treatment planning and coordination",
          type: rowTypes.PROGRAM_INDICATOR,
        },

        // Coverage evaluation
        { name: "Coverage Evaluation", type: rowTypes.CATEGORY },
        {
          name:
            "IUs where MDA treatment coverage was verified and addressed using SCT",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs not meeting the cut-off value for SCT",
          type: rowTypes.PROGRAM_INDICATOR,
        },
      ];

      // Set up column headers and subheaders
      $("#header-row-top").append(`<th scope="col"></th>`);
      $("#header-row-bottom").append(`<th scope="col"></th>`);
      columns.forEach((col) => {
        if (col.subcategories) {
          // 1. Make the top row th colspan = col.subcategories.length
          $("#header-row-top").append(
            `<th scope="col" colspan="${col.subcategories.length}">${col.name}</th>`
          );
          // 2. Make a bottom row th for each subcategory
          col.subcategories.forEach((sc) => {
            $("#header-row-bottom").append(`<th scope="col">${sc}</th>`);
          });
          return;
        }
        // Else, th with col name on top header row, empty cell on bottom
        $("#header-row-top").append(`<th scope=col>${col.shortName}</th>`);
        $("#header-row-bottom").append(`<th scope="col"></th>`);
      });

      // Set up table body to be populated
      const totalColumns =
        1 +
        columns.reduce(
          (sum, column) =>
            sum + (column.subcategories ? column.subcategories.length : 1),
          0
        );
      const dimensionsToQuery = [];
      const tbody = $("#tbody");

      // Set up table body
      rows.forEach((row) => {
        // Make new row object
        const newRow = $(
          `<tr data-name="${row.name}" data-type="${row.type}"></tr>`
        );
        // Add new row to DOM
        tbody.append(newRow);

        if (row.type === rowTypes.CATEGORY) {
          // Row is just a category label (like "Coverage Evaluation"): make one wide cell and return
          newRow.append(
            `<th scope="row" colspan="${totalColumns}">${row.name}</th>`
          );
          return;
        }

        // Add row header with name
        newRow.append(`<th scope="row">${row.name}</th>`);

        /* Brainstorming for "manual columns"
          if (row.manualDimensions) {
            row.manualDimensions.forEach(dimensionName)
            // 1. Find dimension ID from allDimensions
            // 2. Make a <td> cell w/ data-dimension-id=${dimension.id}
            // 3. Add dimension.id to list to query
            // 4. If dimension not found, make cell saying so
          }
          */

        // Add data cells
        columns.forEach((col) => {
          // 0. If column is "grand total", set up cell to receive sum later
          if (col.name === "Grand Total") {
            newRow.append(`<td class="total">Loading...</td>`);
            return;
          }

          // 1. Check if column has subcategories
          if (col.subcategories) {
            // Subcategory strategy:
            // A. Check for aggregate dimension (without suffix)
            // If present, add empty cells for "rounds" and a cell with data in "total"; return
            const dimensionName = `${col.prefix} - ${row.name}`; // e.g. "TMDA - Endemic IUs"
            const dimension = allDimensions.find(
              (dim) => dim.displayName === dimensionName
            );
            if (dimension) {
              col.subcategories.forEach((subcategory) => {
                // Empty cells if not in "Total" column
                if (subcategory !== columnSubcategories.TOTAL) {
                  newRow.append("<td></td>");
                  return;
                }
                // Data for "total" column
                newRow.append(
                  `<td class="subtotal" data-dim-id=${dimension.id}>Loading...</td>`
                );
                // Add dimension to list to query
                dimensionsToQuery.push(dimension.id);
              });
              return;
            }

            // B. Check for subcategory dimension
            // If present, add filled cells for each subcat
            col.subcategories.forEach((subcategory) => {
              const subcatDimensionName = `${dimensionName} ${subcategory}`; // e.g. "OMDA - Population in NTD affected IUs Round 2"

              const subcatDimension = allDimensions.find(
                (dim) => dim.displayName === subcatDimensionName
              );

              if (subcatDimension) {
                // Dimension found: make new cell and return
                const dimensionId = subcatDimension.id;
                // Make cell; give it a target to be filled with data
                newRow.append(
                  `<td ${
                    subcategory === columnSubcategories.TOTAL
                      ? 'class="subtotal"'
                      : null
                  } data-dim-id=${dimensionId}>Loading...</td>`
                );
                // Add dimension to list to query
                dimensionsToQuery.push(dimensionId);
                return;
              }

              // Dimension not found; add cell with message
              newRow.append(
                `<td>(dimension not found: "${subcatDimensionName}")</td>`
              );
            });
            return; // Done with subcategories
          }

          // 2. If no subcategories, look for data for cell (use row name & col prefix)
          const dimensionName = `${col.prefix} - ${row.name}`; // e.g. "TCMDA - Endemic IUs"

          const dimension = allDimensions.find((dim) => {
            // Regex matching to be more flexible (case insensitive, works w/o spaces)
            const re = new RegExp(dimensionName, "i");
            return re.test(dim.displayName);
          });

          // If dimension found, make new cell and prep it for data
          if (dimension) {
            const dimensionId = dimension.id;
            // Make cell; give it a target to be filled with data
            newRow.append(
              `<td class="subtotal" data-dim-id=${dimensionId}>Loading...</td>`
            );
            // Add dimension to list to query
            dimensionsToQuery.push(dimensionId);
            return;
          }

          // If dimension not found, add cell saying so:
          newRow.append(`<td>(dimension not found: "${dimensionName}")</td>`);

          // TODO: Maybe, if data is not found, check /api/programIndicators with case insensitivity to see if field exists
        });
      }); // End table body row population

      // API call to fetch analytics data
      $.get(
        "../api/analytics",
        {
          dimension: `dx:${dimensionsToQuery.join(";")},pe:${period}`,
          filter: `ou:${orgUnit}`,
          skipMeta: true,
        },
        (json) => {
          // console.log("Analytics results: ", json.rows);

          // Fill cells that returned data; put "-" in ones that didn't
          dimensionsToQuery.forEach((dim) => {
            const cellContent =
              json.rows.find((row) => row[0] === dim)?.[2] || "-";
            $(`td[data-dim-id=${dim}]`).text(cellContent);
          });

          // Sum up subtotals for "Grand Total" column
          // 0. Get all non-category rows
          const tableRows = $(
            `tbody > tr:not([data-type="${rowTypes.CATEGORY}"])`
          ).toArray();
          // 1. For each row, find all cells with class .subtotal
          tableRows.forEach((row) => {
            const jqRow = $(row);
            const subtotalCells = jqRow.find(".subtotal").toArray();

            // 2. Sum up contents of those cells
            const sum = subtotalCells.reduce((sum, node) => {
              if (isNaN(node.textContent)) return sum;
              return sum + Number(node.textContent);
            }, 0);

            // 3. Plug in that sum to the cell with class .total
            const formattedSum = sum.toFixed(1).replace(".0", "");
            jqRow.find(".total").text(formattedSum);
          });
        }
      ); // End $.get()
    }); // End Promise.all()
  });
</script>

<!-- Bootstrap test -->
<link
  rel="stylesheet"
  href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
  integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
  crossorigin="anonymous"
/>

<div>
  <!-- Put your HTML mark-up here -->

  <h4>Notes:</h4>
  <p>
    To avoid double-counting the values in the "Round 1/2" columns, the grand
    total currently adds up values in the subtotal columns (or columns without
    rounds)
  </p>
  <p>
    So we can make sure we're querying the right things, "dimension not found"
    indicates fields that weren't found in the lists of indicators or program
    indicators. Of course, some of them should be blank in the end.
  </p>
  <p>
    A cell showing "-" means that the dimension <em>was</em> found, but no data
    was found for it in the database.
  </p>

  <hr />

  <h1>MDA Treatment Summary</h1>

  <p id="loading">Loading...</p>

  <table id="table1" class="table">
    <thead id="thead">
      <tr id="header-row-top">
        <!-- Script will populate col headers here -->
      </tr>
      <tr id="header-row-bottom">
        <!-- Script will populate col subheaders here-->
      </tr>
    </thead>
    <tbody id="tbody">
      <!-- Script will populate rows here -->
    </tbody>
  </table>
</div>
