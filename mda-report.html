<style type="text/css" media="screen">
  /* Put your CSS styling here */

  /* Rows that are not category labels */
  th[scope="row"]:not([colspan]) {
    font-weight: normal;
  }
</style>

<script type="text/javascript">
  // Put your javascript functions here

  // Defining these values here because form creation error isn't saving report parameter settings
  const period = dhis2.report.periods[0] || "THIS_YEAR";
  const orgUnit = dhis2.report.organisationUnit.length
    ? dhis2.report.organisationUnit
    : {
        id: "GdH306UQ8L8", // This is the global org-unit
        name: "ASCEND",
        code: "",
      };

  function getAllDimensions() {
    // Gets a list of all indicators' and program indicators' names and IDs
    return Promise.all([
      $.get(
        "../api/programIndicators.json?filter=displayName:like:MDA&paging=false"
      ),
      $.get("../api/indicators.json?filter=displayName:like:MDA&paging=false"),
    ]).then(values => {
      const [{ programIndicators }, { indicators }] = values;
      const allDimensions = [...programIndicators, ...indicators];
      return allDimensions;
    });
  }

  jQuery(document).ready(function () {
    // Put javascript to be executed after page is loaded here

    // Parallel promises to fetch indicators and programIndicators
    getAllDimensions().then((allDimensions) => {
      console.log("All dimensions: ", allDimensions);

      // Remove "loading"
      $("#loading").remove();

      /* Setting up table */
      // Some enums I might use
      const columnSubcategories = Object.freeze({
        ROUND_1: "Round 1",
        ROUND_2: "Round 2",
        TOTAL: "Total",
      });
      const rowTypes = Object.freeze({
        CATEGORY: "category",
        PROGRAM_INDICATOR: "programIndicator",
        INDICATOR: "indicator",
      });
      // Enum for program indicator names? -- Maybe not, just put it in `rows`

      // Column and row values
      // TODO: Add short names
      const columns = [
        {
          name: "Trachoma MDA",
          shortName: "Trach.",
          prefix: "TCMDA",
          subcategories: null,
        },
        {
          name: "Lymphatic Filariasis MDA",
          shortName: "L.F.",
          prefix: "LFMDA",
          subcategories: null,
        },
        {
          name: "Onchocerciasis MDA",
          shortName: "Oncho.",
          prefix: "OMDA",
          subcategories: [
            columnSubcategories.ROUND_1,
            columnSubcategories.ROUND_2,
            columnSubcategories.TOTAL,
          ],
        },
        {
          name: "Schistosomiasis MDA",
          shortName: "Schisto.",
          prefix: "SCMDA",
          subcategories: [
            columnSubcategories.ROUND_1,
            columnSubcategories.ROUND_2,
            columnSubcategories.TOTAL,
          ],
        },
        {
          name: "Soil-transmitted Helminthiasis MDA",
          shortName: "STH",
          prefix: "STMDA",
          subcategories: [
            columnSubcategories.ROUND_1,
            columnSubcategories.ROUND_2,
            columnSubcategories.TOTAL,
          ],
        },
        {
          name: "Grand Total",
          shortName: "Grand Total",
          prefix: null,
          subcategories: null,
        },
      ];

      // If cell definitions are not manually defined, they are estimated based on row / title info
      const rows = [
        // Endemicity
        { name: "Endemicity", type: rowTypes.CATEGORY },
        { name: "Endemic IUs", type: rowTypes.PROGRAM_INDICATOR },
        {
          name: "IUs which reached the criteria to stop MDA",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs in post-treatment surveillance",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs eligible for post MDA surveillance phase",
          type: rowTypes.PROGRAM_INDICATOR,
          // An example of manually-defined cells: `null` for empty cells, "Grand total" at the end
          cellDimensions: [
            {
              dimensionName:
                "TCMDA - IUs eligible for post MDA surveillance phase",
              // "Subtotal" specifies whether to add this value to the grand total
              subtotal: true,
            },
            {
              dimensionName:
                "LFMDA - IUs eligible for post MDA surveillance phase",
              subtotal: true,
            },
            // Empty cells:
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            // Grand total cell will receive sum of subtotals
            { dimensionName: "Grand Total", subtotal: false },
          ],
        },
        {
          name: "IUs where NTD endemicity is unknown",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "Population in NTD affected IUs",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs eligible for pre-TAS surveys",
          type: rowTypes.PROGRAM_INDICATOR,
          cellDimensions: [
            null,
            {
              dimensionName: "LFMDA - IUs eligible for pre-TAS surveys",
              subtotal: true,
            },
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            { dimensionName: "Grand Total" },
          ],
        },
        {
          name: "IUs eligible for TAS/IA surveys",
          type: rowTypes.PROGRAM_INDICATOR,
          cellDimensions: [
            {
              dimensionName: "TCMDA - IUs eligible for TAS/IA surveys",
              subtotal: true,
            },
            {
              dimensionName: "LFMDA - IUs eligible for TAS/IA surveys",
              subtotal: true,
            },
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            { dimensionName: "Grand Total" },
          ],
        },

        // Targets
        { name: "Targets", type: rowTypes.CATEGORY },
        { name: "Total Population of IUs", type: rowTypes.PROGRAM_INDICATOR },
        {
          name: "Population eligible for MDA treatment",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "Estimated size of populations with high risk of infection",
          type: rowTypes.PROGRAM_INDICATOR,
        },

        // Coverage
        { name: "Coverage", type: rowTypes.CATEGORY },
        // {
        //   // Causes "division by zero" error in database, specifically from TCMDA (uses "Epidemiological")
        //   name: "National Coverage",
        //   type: rowTypes.PROGRAM_INDICATOR,
        // },
        { name: "Program Coverage", type: rowTypes.PROGRAM_INDICATOR },
        // {
        //   // Same "division" error as above b/c TCMDA and LFMDA
        //   name: "Epidemiological Coverage",
        //   type: rowTypes.PROGRAM_INDICATOR,
        // },
        {
          name: "IUs reaching targeted program coverage",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name:
            "IUs reaching target therapeutic coverage within populations with high risk of infection",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs where MDA treatment has been provided",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "MDA treatments distributed to high risk populations",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        // Display name: "Number of PC treatments provided per IU (per disease)"
        { name: "Total Persons Treated", type: rowTypes.PROGRAM_INDICATOR },
        {
          name: "IUs where MDA campaigns were conducted",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs reaching required therapeutic coverage",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        // Similar to above, so displayName: "Number of people, in population eligible for treatment, receiving MDA treatment"
        { name: "Total Persons Treated", type: rowTypes.PROGRAM_INDICATOR },
        // This one seems off
        {
          name:
            "People, in population eligible for treatment, not receiving MDA treatment",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IU supported with NTD MDA treatment planning and coordination",
          type: rowTypes.PROGRAM_INDICATOR,
        },

        // Coverage evaluation
        { name: "Coverage Evaluation", type: rowTypes.CATEGORY },
        {
          name:
            "IUs where MDA treatment coverage was verified and addressed using SCT",
          type: rowTypes.PROGRAM_INDICATOR,
        },
        {
          name: "IUs not meeting the cut-off value for SCT",
          type: rowTypes.PROGRAM_INDICATOR,
        },
      ];

      // Set up column headers and subheaders
      $("#header-row-top").append(`<th scope="col"></th>`);
      $("#header-row-bottom").append(`<th scope="col"></th>`);
      columns.forEach((col) => {
        if (col.subcategories) {
          // 1. Make the top row th colspan = col.subcategories.length
          $("#header-row-top").append(
            `<th scope="col" colspan="${col.subcategories.length}">${col.name}</th>`
          );
          // 2. Make a bottom row th for each subcategory
          col.subcategories.forEach((sc) => {
            $("#header-row-bottom").append(`<th scope="col">${sc}</th>`);
          });
          return;
        }
        // Else, th with col name on top header row, empty cell on bottom
        $("#header-row-top").append(`<th scope=col>${col.shortName}</th>`);
        $("#header-row-bottom").append(`<th scope="col"></th>`);
      });

      // Set up table body to be populated
      const totalColumns =
        1 +
        columns.reduce(
          (sum, column) =>
            sum + (column.subcategories ? column.subcategories.length : 1),
          0
        );
      const dimensionsToQuery = [];
      const tbody = $("#tbody");

      // Set up table body
      rows.forEach((row) => {
        // Make new row object
        const newRow = $(
          `<tr data-name="${row.name}" data-type="${row.type}"></tr>`
        );
        // Add new row to DOM
        tbody.append(newRow);

        if (row.type === rowTypes.CATEGORY) {
          // Row is just a category label (like "Coverage Evaluation"): make one wide cell and return
          newRow.append(
            `<th scope="row" colspan="${totalColumns}">${row.name}</th>`
          );
          return;
        }

        // Add row header with name
        newRow.append(`<th scope="row">${row.name}</th>`);

        // Handling manually-defined dimension names
        if (row.cellDimensions) {
          // Cells are manually defined. Iterate over dimension definitions to make row
          row.cellDimensions.forEach((cell) => {
            // If dimension name is empty, make empty cell
            if (!cell) return newRow.append(`<td></td>`);

            const { dimensionName, subtotal } = cell;

            if (dimensionName === "Grand Total") {
              newRow.append(`<td class="total">Loading...</td>`);
              return;
            }

            // Look up dimension ID from `allDimensions`
            const dimension = allDimensions.find(
              (dim) => dim.displayName === dimensionName
            );

            if (!dimension) {
              // Dimension not found. Add cell saying so:
              newRow.append(
                `<td>(dimension not found: "${dimensionName}")</td>`
              );
              return;
            }

            // Dimension found. Make cell; give it a target to be filled with data
            newRow.append(
              `<td ${subtotal ? 'class="subtotal"' : null} data-dim-id=${
                dimension.id
              }>Loading...</td>`
            );
            // Add dimension to list to query
            dimensionsToQuery.push(dimension.id);
          });
          return;
        }

        // Cells are not manually defined; create them based on column definiitions
        columns.forEach((col) => {
          // 0. If column is "grand total", set up cell to receive sum later
          if (col.name === "Grand Total") {
            newRow.append(`<td class="total">Loading...</td>`);
            return;
          }

          // 1. Check if column has subcategories
          if (col.subcategories) {
            // Subcategory strategy:
            // A. Check for aggregate dimension (without suffix)
            // If present, add empty cells for "rounds" and a cell with data in "total"; return
            const dimensionName = `${col.prefix} - ${row.name}`; // e.g. "TMDA - Endemic IUs"
            const dimension = allDimensions.find(
              (dim) => dim.displayName === dimensionName
            );
            if (dimension) {
              col.subcategories.forEach((subcategory) => {
                // Empty cells if not in "Total" column
                if (subcategory !== columnSubcategories.TOTAL) {
                  newRow.append("<td></td>");
                  return;
                }
                // Data for "total" column
                newRow.append(
                  `<td class="subtotal" data-dim-id=${dimension.id}>Loading...</td>`
                );
                // Add dimension to list to query
                dimensionsToQuery.push(dimension.id);
              });
              return;
            }

            // B. Check for subcategory dimension
            // If present, add filled cells for each subcat
            col.subcategories.forEach((subcategory) => {
              const subcatDimensionName = `${dimensionName} ${subcategory}`; // e.g. "OMDA - Population in NTD affected IUs Round 2"

              const subcatDimension = allDimensions.find(
                (dim) => dim.displayName === subcatDimensionName
              );

              if (subcatDimension) {
                // Dimension found: make new cell and return
                const dimensionId = subcatDimension.id;
                // Make cell; give it a target to be filled with data
                newRow.append(
                  `<td ${
                    subcategory === columnSubcategories.TOTAL
                      ? 'class="subtotal"'
                      : null
                  } data-dim-id=${dimensionId}>Loading...</td>`
                );
                // Add dimension to list to query
                dimensionsToQuery.push(dimensionId);
                return;
              }

              // Dimension not found; add cell with message
              newRow.append(
                `<td>(dimension not found: "${subcatDimensionName}")</td>`
              );
            });
            return; // Done with subcategories
          }

          // 2. If no subcategories, look for data for cell (use row name & col prefix)
          const dimensionName = `${col.prefix} - ${row.name}`; // e.g. "TCMDA - Endemic IUs"

          const dimension = allDimensions.find((dim) => {
            // Regex matching to be more flexible (case insensitive, works w/o spaces)
            const re = new RegExp(dimensionName, "i");
            return re.test(dim.displayName);
          });

          // If dimension found, make new cell and prep it for data
          if (dimension) {
            const dimensionId = dimension.id;
            // Make cell; give it a target to be filled with data
            newRow.append(
              `<td class="subtotal" data-dim-id=${dimensionId}>Loading...</td>`
            );
            // Add dimension to list to query
            dimensionsToQuery.push(dimensionId);
            return;
          }

          // If dimension not found, add cell saying so:
          newRow.append(`<td>(dimension not found: "${dimensionName}")</td>`);

          // TODO: Maybe, if data is not found, check /api/programIndicators with case insensitivity to see if field exists
        });
      }); // End table body row population

      // API call to fetch analytics data
      $.get(
        "../api/analytics",
        {
          dimension: `dx:${dimensionsToQuery.join(";")},pe:${period}`,
          filter: `ou:${orgUnit.id}`,
          skipMeta: true,
        },
        (json) => {
          // console.log("Analytics results: ", json.rows);

          // Fill cells that returned data; put "-" in ones that didn't
          dimensionsToQuery.forEach((dim) => {
            const cellContent =
              json.rows.find((row) => row[0] === dim)?.[2] || "-";
            $(`td[data-dim-id=${dim}]`).text(cellContent);
          });

          // Sum up subtotals for "Grand Total" column
          // 0. Get all non-category rows
          const tableRows = $(
            `tbody > tr:not([data-type="${rowTypes.CATEGORY}"])`
          ).toArray();
          // 1. For each row, find all cells with class .subtotal
          tableRows.forEach((row) => {
            const jqRow = $(row);
            const subtotalCells = jqRow.find(".subtotal").toArray();

            // 2. Sum up contents of those cells
            const sum = subtotalCells.reduce((sum, node) => {
              if (isNaN(node.textContent)) return sum;
              return sum + Number(node.textContent);
            }, 0);

            // 3. Plug in that sum to the cell with class .total
            const formattedSum = sum.toFixed(1).replace(".0", "");
            jqRow.find(".total").text(formattedSum);
          });
        }
      ); // End $.get()
    }); // End Promise.all()
  });
</script>

<!-- Bootstrap test -->
<link
  rel="stylesheet"
  href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
  integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
  crossorigin="anonymous"
/>

<div>
  <!-- Put your HTML mark-up here -->

  <h4>Notes:</h4>
  <p>
    To avoid double-counting the values in the "Round 1/2" columns, the grand
    total currently adds up values in the subtotal columns (or columns without
    rounds)
  </p>
  <p>
    So we can make sure we're querying the right things, "dimension not found"
    indicates fields that weren't found in the lists of indicators or program
    indicators. Of course, some of them should be blank in the end.
  </p>
  <p>
    A cell showing "-" means that the dimension <em>was</em> found, but no data
    was found for it in the database.
  </p>

  <hr />

  <h1>MDA Treatment Summary</h1>

  <p id="loading">Loading...</p>

  <table id="table1" class="table">
    <thead id="thead">
      <tr id="header-row-top">
        <!-- Script will populate col headers here -->
      </tr>
      <tr id="header-row-bottom">
        <!-- Script will populate col subheaders here-->
      </tr>
    </thead>
    <tbody id="tbody">
      <!-- Script will populate rows here -->
    </tbody>
  </table>
</div>
